#include <LiquidCrystal_I2C.h>
#include <Wire.h>
#include <Preferences.h>
#include "TinyGPS++.h"
#include <Adafruit_LSM6DSOX.h>
#include <Stepper.h>

using namespace std;


#define IN1 19
#define IN2 18
#define IN3 5
#define IN4 21
#define RXD2 16
#define TXD2 17

// For SPI mode, we need a CS pin
#define LSM_CS 10   // CS pin
// For software-SPI mode we need SCK/MOSI/MISO pins
#define LSM_SCK 12  // SCL pin
#define LSM_MISO 13 // DO pin
#define LSM_MOSI 11 // SDA pin

const int LCD_SDA = 8;
const int LCD_SCL = 7;
const int POT_PIN = 4;
const int BUTTON = 41;
const int stepsPerRevolution = 2048;  // change this to fit the number of steps per revolution

Preferences prefs;
LiquidCrystal_I2C lcd(0x27, 16, 2);
HardwareSerial neogps(1);
TinyGPSPlus gps;
Stepper myStepper(stepsPerRevolution, IN1, IN3, IN2, IN4);


/*
  state is selection between choosing checkpoint or new checkpoint
  scrolls through different Lodestone options and able to select them
  they all being as "unsaved" then saves current location after button press
  and then becomes "saved". If you ever press button on a saved one, it becomes 
  the new tracking target. The state will then be "tracking". The needle will point
  to this new target.
*/
// 0 = unsaved 1 = saved 2 = tracking
int lodestate1 = 0; //First lodestone state 
int lodestate2 = 0; //Second loadstone state
int lodestate3 = 0; //Third loadstone state
int trackingLode = 0; //Tracks X lode

int potVal = 0;

double angleG = 0; //Angle value generated by gyroscope
double angleP = 0; //Position angle that servos needs to adjust

double lat1 = 0.0, long1 = 0.0;  
double lat2 = 0.0, long2 = 0.0;  
double lat3 = 0.0, long3 = 0.0;   

// Use float for lat/lng (for decimal precision)
float longitude = NAN;
float latitude = NAN;
float target_lng = NAN;
float target_lat = NAN;

// IDK wht this is, the tutorial has it...
Adafruit_LSM6DSOX sox;

// varible to store yawAngle
static double yawAngle = 0;

// Get angle offset values
double xDegOffset;
double yDegOffset;
double zDegOffset;

// Setting up gyro sensor config
sensors_event_t accel;
sensors_event_t gyro;
sensors_event_t temp;


bool buttonPress(){
  delay(100);
  return digitalRead(BUTTON) == 0;
}

int updateLodestate(int& loadstate){
    if(loadstate != 2){
      ++loadstate;
    }
    if(loadstate == 2){
      if(lodestate1){
        lodestate1 = 1;
      }
      if(lodestate2){
        lodestate2 = 1;
      }
      if(lodestate3){
        lodestate3 = 1;
      }
      loadstate = 2;
    }
  return loadstate;
}
void printLodestate(int loadstate){
  if(loadstate == 0){
    lcd.setCursor(0,1);
    lcd.print("Missing Coords     ");
  }
  if(loadstate == 1){
    lcd.setCursor(0,1);
    lcd.print("Saved Coords       ");
  }
  if(loadstate == 2){
    lcd.setCursor(0,1);
    lcd.print("Tracking Coords    ");
  }
}

void calibrate(sensors_event_t gyroSensor)
{
  Serial.println("Currently Calibrating...");
  // Basically getting the average values, after timePasses seconds of reading

  unsigned long timePassed = 10 * 1000; // calibration time
  unsigned long timeStart = millis();

  // Acumulators for the average readings
  double xTotal = 0;
  double yTotal = 0;
  double zTotal = 0;

  // Counter for how many readings occured
  int counter = 0;

  while (millis() - timeStart < timePassed)
  {
    xTotal += gyroSensor.gyro.x;
    yTotal += gyroSensor.gyro.y;
    zTotal += gyroSensor.gyro.z;

    counter++;
  }

  // Comput averages, store to pointers
  xDegOffset = xTotal / counter;
  yDegOffset = yTotal / counter;
  zDegOffset = zTotal / counter;

  //Serial.println(zDegOffset);

  Serial.println("Finish Calibrating.");
}

// NOTE, prevAngle is a global variable...
double updateYawAngle(sensors_event_t gyroSensor)
{
  // For yaw angle, only focus on z-axis.
  //  - angle used trapezoidal apporox, where
  //.   b1: first angle reading
  //.   b2: second angle reading
  //.    h: sampleRate
  static bool calculate = false;
  
  // Constant to format angle
  // 33: so every 90 degrees, the value is 1.
  float sensorConst = 33;
  float sampleRate = 0.0001 * sensorConst;
  unsigned long timeInterval = sampleRate * 1000; 


  // Read the z value
  static float base1 = gyroSensor.gyro.z;
  static float base2  = 0;
  double area = 0;
  if(!calculate){
    base1 = gyroSensor.gyro.z;
    delay(timeInterval);
    base2 = gyroSensor.gyro.z;
    area = (base1 + base2 + zDegOffset) * (0.5);
    calculate = true;
    area *= sampleRate;
    yawAngle += area;
  }
  // Serial.print("1 ");
  // Serial.println(base1);

  // wait the same amout as sampling rate
  static unsigned long startTime = 0;
  if(millis() - startTime >= timeInterval)
  {
    base1 = base2;
    base2 = gyroSensor.gyro.z;
    area = (base1 + base2 - 2 * zDegOffset) * (0.5);
    startTime = millis();
    area *= sampleRate;
    yawAngle += area;
  }
  


  // Reset value if yawAngle > 4, or yawAngle < -4
  if (yawAngle > 4)
  {
    yawAngle -= 4;
  }
  if (yawAngle < -4)
  {
    yawAngle += 4;
  }

  //Serial.println(yawAngle);

  double output = formatYawAngle();

  return -1 * output;
}

double formatYawAngle(void)
{
  // yawAngle is 1 when 90 degrees, so the range should be
  // from (-2, 2). 

  // Get the true angle, where
  // left side of circle is positive
  // right side of circle is negative
  // both side range from 0-180 deg
  
  double formatAngle = yawAngle;

  // format if negative
  if (formatAngle > 2)
  {
    // Update angle to negative
    formatAngle = -2 + (formatAngle - 2);
  }
  if (formatAngle < -2)
  {
    // update to positive
    formatAngle = 2 + (formatAngle + 2);
  }

  // Multiply 90 to correct format
  formatAngle *= 90;
  return formatAngle;
}

void adjustNeedle(){
  sox.getEvent(&accel, &gyro, &temp);
  /* Display the results (rotation is measured in rad/s) */
  Serial.println(updateYawAngle(gyro));
}

void updateCoords(int num){
  double coordLat = 0.0;
  double coordLong =  0.0;
  String latKey = "lat" + String(num);
  String longKey = "long" + String(num);

  double existingLat = prefs.getDouble(latKey.c_str(), -999.0);
  double existingLong = prefs.getDouble(longKey.c_str(), -999.0);
  if (existingLat != coordLat) {
    prefs.putDouble(latKey.c_str(), coordLat);
  }
  if (existingLong != coordLong) {
    prefs.putDouble(longKey.c_str(), coordLong);
  }
  prefs.end();
}

void menu(){
  potVal = analogRead(POT_PIN);
  if(potVal <= 30){
      lcd.setCursor(0,0);
      lcd.print("Use Dial to     ");
      lcd.setCursor(0,1);
      lcd.print("Select Lodestone   ");
  }
  else if(potVal <= 1200){
    lcd.setCursor(0,0);
    lcd.print("Lodestone 1      ");
    printLodestate(lodestate1);
    if(buttonPress()){
        updateLodestate(lodestate1);
        printLodestate(lodestate1);
        updateCoords(1);
      }
  }
  else if(potVal <= 2400){
    lcd.setCursor(0,0);
    lcd.print("Lodestone 2      ");
    printLodestate(lodestate2);
    if(buttonPress()){
        updateLodestate(lodestate2);
        printLodestate(lodestate2);
        updateCoords(2);
      }
  }
  else if(potVal <= 3600){
    lcd.setCursor(0,0);
    lcd.print("Lodestone 3       ");
    printLodestate(lodestate3);
    if(buttonPress()){
        updateLodestate(lodestate3);
        printLodestate(lodestate3);
        updateCoords(3);
      }
  }
}

void setup() {
  Serial.begin(115200);
  Wire.begin(LCD_SDA, LCD_SCL);
  lcd.init();
  lcd.backlight();
  pinMode(POT_PIN, INPUT);
  pinMode(BUTTON, INPUT_PULLUP);
  delay(500);  // Give time for Serial to initialize

  Serial.println("Adafruit LSM6DSOX test!");

  if (!sox.begin_I2C()) {
    if (!sox.begin_SPI(LSM_CS)) {
      if (!sox.begin_SPI(LSM_CS, LSM_SCK, LSM_MISO, LSM_MOSI)) {
        Serial.println("Failed to find LSM6DSOX chip");
        Serial.print("MOSI: ");
        Serial.println(MOSI);
        Serial.print("SCK: ");
        Serial.println(SCK);
        Serial.print("MISO: ");
        Serial.println(MISO);

        while (1) {
          delay(10);
        }
      }
    }
  }

  Serial.println("LSM6DSOX Found!");

  // Set the offset values as zero
  xDegOffset = 0;
  yDegOffset = 0;
  zDegOffset = 0;

  // Something from the Adafruit's tutorial???
  sox.getEvent(&accel, &gyro, &temp);

  calibrate(gyro);
}


void loop() {
  menu();
  adjustNeedle();
  Serial.print("Potval: ");  
  Serial.println(potVal);

}
